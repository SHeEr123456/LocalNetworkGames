<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>局域网游戏对战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(to right, #8B0000, #B22222);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .connection-panel {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .connection-panel h3 {
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .input-group input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #8B0000;
            color: white;
        }

        .btn-success:hover {
            background: #B22222;
            transform: translateY(-2px);
        }

        .status-box {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }

        .game-container {
            display: flex;
            padding: 20px;
            gap: 20px;
            min-height: 600px;
        }

        .board-section {
            flex: 3;
        }

        .info-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #chessboard {
            width: 540px;
            height: 600px;
            margin: 0 auto;
            background: #F0DCA0;
            border: 3px solid #8B4513;
            position: relative;
        }

        #tankCanvas {
            width: 800px;
            height: 600px;
            border: 2px solid #444;
            background: #0f3b0f;
            display: block;
            margin: 0 auto;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .info-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .info-card h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        #playerInfo {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #playerInfo h3 {
            color: white;
            border-bottom: 2px solid rgba(255,255,255,0.3);
        }

        #chatMessages {
            height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-radius: 5px;
            border-left: 3px solid #4CAF50;
        }

        .chat-message.system {
            border-left-color: #2196F3;
            background: #e3f2fd;
        }

        .chat-message.opponent {
            border-left-color: #FF9800;
            background: #fff3e0;
        }

        .chat-input {
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        #moveHistory {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .move-record {
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .piece {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
            user-select: none;
        }

        .piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            z-index: 20;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #FF6347, #B22222);
            color: #FFD700;
            text-shadow: 1px 1px 2px black;
        }

        .piece.black {
            background: radial-gradient(circle at 30% 30%, #696969, #000000);
            color: #C0C0C0;
            text-shadow: 1px 1px 2px black;
        }

        .piece.selected {
            box-shadow: 0 0 20px #FFD700;
            z-index: 30;
        }

        .valid-move {
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            z-index: 5;
            cursor: pointer;
        }

        .river {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 60px;
            margin-top: -30px;
            background: rgba(139, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #8B0000;
            pointer-events: none;
        }

        .instructions {
            margin: 20px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }

        .instructions h4 {
            margin-bottom: 10px;
            color: #2e7d32;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.5;
        }

        .room-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .room-item {
            padding: 10px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .room-item:hover {
            background: #e0e0e0;
        }

        .room-item.active {
            background: #bbdefb;
            border-left: 3px solid #2196F3;
        }

        .grid-line {
            position: absolute;
            background: #8B4513;
        }

        @media (max-width: 1024px) {
            .game-container {
                flex-direction: column;
            }
            
            #chessboard {
                width: 100%;
                max-width: 540px;
                height: 600px;
            }
        }

        @media (max-width: 600px) {
            #chessboard {
                height: 400px;
            }
            
            .piece {
                width: 37px;
                height: 37px;
                font-size: 16px;
            }
            
            .river {
                font-size: 18px;
                height: 40px;
                margin-top: -20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>局域网游戏对战</h1>
            <p>与朋友在同一局域网内进行实时对战</p>
        </div>

        <div class="connection-panel" id="connectionPanel">
            <h3>连接设置</h3>
            <div class="input-group">
                <input type="text" id="serverAddress" placeholder="服务器地址 (例如: 192.168.1.100:3000)" value="localhost:3000">
                <button class="btn btn-primary" onclick="connectToServer()">连接服务器</button>
            </div>
            <div class="input-group">
                <select id="gameSelect" style="padding:12px;border:2px solid #ddd;border-radius:5px;min-width:160px;">
                    <option value="chess">中国象棋</option>
                    <option value="tank">坦克大战</option>
                </select>
                <button class="btn btn-secondary" onclick="createRoom()">创建新房间</button>
                <button class="btn btn-secondary" onclick="refreshRoomList()">刷新房间列表</button>
            </div>
            
            <div id="roomListContainer" style="display: none;">
                <h4>可用房间:</h4>
                <div class="room-list" id="roomList"></div>
            </div>
            
            <div class="status-box" id="connectionStatus">
                等待连接服务器...
            </div>
        </div>

        <div class="game-container" style="display: none;" id="gameContainer">
            <div class="board-section">
                <div id="chessboard">
                    <div class="river">楚河        汉界</div>
                </div>
                <div id="tankContainer" style="display:none;">
                    <canvas id="tankCanvas" width="800" height="600"></canvas>
                    <div style="text-align:center;margin-top:10px;color:#333;">WASD移动，J射击</div>
                </div>
                <div class="controls">
                    <button class="btn btn-success" onclick="restartGame()">重新开始</button>
                    <button class="btn" onclick="surrenderGame()">认输</button>
                    <button class="btn" onclick="toggleSound()">音效: 开</button>
                </div>
            </div>
            
            <div class="info-section">
                <div class="info-card" id="playerInfo">
                    <h3>玩家信息</h3>
                    <div>你的颜色: <span id="playerColor" style="font-weight: bold;">未连接</span></div>
                    <div>当前回合: <span id="currentTurn" style="font-weight: bold;">等待开始</span></div>
                    <div>房间号: <span id="roomId" style="font-weight: bold;">-</span></div>
                </div>
                
                <div class="info-card">
                    <h3>聊天室</h3>
                    <div id="chatMessages"></div>
                    <div class="chat-input">
                        <input type="text" id="chatInput" placeholder="输入消息..." onkeypress="handleChatKeyPress(event)">
                        <button class="btn btn-primary" onclick="sendChatMessage()">发送</button>
                    </div>
                </div>
                
                <div class="info-card">
                    <h3>棋谱记录</h3>
                    <div id="moveHistory"></div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h4>使用说明：</h4>
            <ul>
                <li><strong>第一步：启动服务器</strong> - 在一台电脑上运行 server.js</li>
                <li><strong>第二步：创建房间</strong> - 房主点击"创建新房间"，成为红方</li>
                <li><strong>第三步：加入房间</strong> - 另一台电脑输入服务器地址，刷新房间列表并加入</li>
                <li><strong>第四步：开始游戏</strong> - 红方先行，轮流走棋</li>
                <li><strong>注意：</strong> 确保所有设备在同一局域网内，防火墙允许3000端口</li>
            </ul>
        </div>
    </div>

    <script>
        // 象棋规则引擎（客户端版本）
        class ChessRules {
            static isValidMove(board, fromRow, fromCol, toRow, toCol) {
                if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return {valid: false};
                if (fromRow === toRow && fromCol === toCol) return {valid: false};
                
                const piece = board[fromRow][fromCol];
                if (!piece) return {valid: false};
                
                const targetPiece = board[toRow][toCol];
                const isRed = piece === piece.toUpperCase();
                
                if (targetPiece) {
                    const isTargetRed = targetPiece === targetPiece.toUpperCase();
                    if (isRed === isTargetRed) return {valid: false};
                }
                
                const pieceType = piece.toLowerCase();
                let isValid = false;
                
                switch (pieceType) {
                    case 'k': isValid = this.isValidKingMove(piece, fromRow, fromCol, toRow, toCol, board); break;
                    case 'a': isValid = this.isValidAdvisorMove(piece, fromRow, fromCol, toRow, toCol); break;
                    case 'b': isValid = this.isValidElephantMove(piece, fromRow, fromCol, toRow, toCol, board); break;
                    case 'n': isValid = this.isValidHorseMove(fromRow, fromCol, toRow, toCol, board); break;
                    case 'r': isValid = this.isValidChariotMove(fromRow, fromCol, toRow, toCol, board); break;
                    case 'c': isValid = this.isValidCannonMove(fromRow, fromCol, toRow, toCol, board, !!targetPiece); break;
                    case 'p': isValid = this.isValidPawnMove(piece, fromRow, fromCol, toRow, toCol); break;
                }
                
                return {
                    valid: isValid,
                    captures: isValid && targetPiece !== null,
                    piece: piece,
                    targetPiece: targetPiece
                };
            }
            
            static isValidKingMove(piece, fromRow, fromCol, toRow, toCol, board) {
                const isRed = piece === 'K';
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                if (rowDiff + colDiff !== 1) return false;
                
                if (isRed) {
                    if (toRow < 7 || toRow > 9 || toCol < 3 || toCol > 5) return false;
                } else {
                    if (toRow < 0 || toRow > 2 || toCol < 3 || toCol > 5) return false;
                }
                
                return !this.isFacingKings(board, toRow, toCol, isRed);
            }
            
            static isFacingKings(board, row, col, isRed) {
                const direction = isRed ? -1 : 1;
                for (let r = row + direction; r >= 0 && r <= 9; r += direction) {
                    const piece = board[r][col];
                    if (piece) {
                        return piece.toLowerCase() === 'k';
                    }
                }
                return false;
            }
            
            static isValidAdvisorMove(piece, fromRow, fromCol, toRow, toCol) {
                const isRed = piece === 'A';
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                if (rowDiff !== 1 || colDiff !== 1) return false;
                
                if (isRed) {
                    return toRow >= 7 && toRow <= 9 && toCol >= 3 && toCol <= 5;
                } else {
                    return toRow >= 0 && toRow <= 2 && toCol >= 3 && toCol <= 5;
                }
            }
            
            static isValidElephantMove(piece, fromRow, fromCol, toRow, toCol, board) {
                const isRed = piece === 'B';
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                if (rowDiff !== 2 || colDiff !== 2) return false;
                
                // 象/相不能过河：红方在下（行数大），黑方在上（行数小）
                // 红象活动范围 5-9 行，不能到 0-4 行
                if (isRed && toRow < 5) return false;
                // 黑相活动范围 0-4 行，不能到 5-9 行
                if (!isRed && toRow > 4) return false;
                
                const eyeRow = (fromRow + toRow) / 2;
                const eyeCol = (fromCol + toCol) / 2;
                return board[eyeRow][eyeCol] === null;
            }
            
            static isValidHorseMove(fromRow, fromCol, toRow, toCol, board) {
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) {
                    return false;
                }
                
                if (rowDiff === 2) {
                    const middleRow = (fromRow + toRow) / 2;
                    if (board[middleRow][fromCol]) return false;
                } else {
                    const middleCol = (fromCol + toCol) / 2;
                    if (board[fromRow][middleCol]) return false;
                }
                
                return true;
            }
            
            static isValidChariotMove(fromRow, fromCol, toRow, toCol, board) {
                if (fromRow !== toRow && fromCol !== toCol) return false;
                
                let step, steps;
                if (fromRow === toRow) {
                    step = fromCol < toCol ? 1 : -1;
                    steps = Math.abs(toCol - fromCol);
                    for (let i = 1; i < steps; i++) {
                        if (board[fromRow][fromCol + i * step]) return false;
                    }
                } else {
                    step = fromRow < toRow ? 1 : -1;
                    steps = Math.abs(toRow - fromRow);
                    for (let i = 1; i < steps; i++) {
                        if (board[fromRow + i * step][fromCol]) return false;
                    }
                }
                
                return true;
            }
            
            static isValidCannonMove(fromRow, fromCol, toRow, toCol, board, isCapture) {
                if (fromRow !== toRow && fromCol !== toCol) return false;
                
                let obstacles = 0;
                let row = fromRow;
                let col = fromCol;
                
                while (row !== toRow || col !== toCol) {
                    if (row < toRow) row++;
                    else if (row > toRow) row--;
                    if (col < toCol) col++;
                    else if (col > toCol) col--;
                    
                    if ((row !== toRow || col !== toCol) && board[row][col]) {
                        obstacles++;
                    }
                }
                
                if (isCapture) {
                    return obstacles === 1;
                } else {
                    return obstacles === 0;
                }
            }
            
            static isValidPawnMove(piece, fromRow, fromCol, toRow, toCol) {
                const isRed = piece === 'P';
                const rowDiff = toRow - fromRow;
                const colDiff = Math.abs(toCol - fromCol);
                
                if (isRed && rowDiff > 0) return false;
                if (!isRed && rowDiff < 0) return false;
                
                const forwardDiff = Math.abs(rowDiff);
                const isCrossedRiver = isRed ? fromRow <= 4 : fromRow >= 5;
                
                if (!isCrossedRiver) {
                    return forwardDiff === 1 && colDiff === 0;
                } else {
                    if (forwardDiff === 1 && colDiff === 0) return true;
                    if (forwardDiff === 0 && colDiff === 1) return true;
                    return false;
                }
            }
            
            static getAllValidMoves(board, row, col) {
                const piece = board[row][col];
                if (!piece) return [];
                
                const moves = [];
                
                for (let toRow = 0; toRow < 10; toRow++) {
                    for (let toCol = 0; toCol < 9; toCol++) {
                        const result = this.isValidMove(board, row, col, toRow, toCol);
                        if (result.valid) {
                            moves.push({row: toRow, col: toCol, captures: result.captures});
                        }
                    }
                }
                
                return moves;
            }
        }

        // 游戏主逻辑
        class OnlineChessGame {
            constructor() {
                this.socket = null;
                this.clientId = null;
                this.roomId = null;
                this.gameType = 'chess';
                this.playerColor = null;
                this.gameState = null;
                this.selectedPiece = null;
                this.validMoves = [];
                this.soundEnabled = true;
                // Tank 专用状态
                this.tankState = null;
                this.tankKeys = { left: false, right: false, up: false, down: false, shoot: false };
                this.tankSendTimer = null;
                this.tankCanvas = document.getElementById('tankCanvas');
                this.tankCtx = this.tankCanvas ? this.tankCanvas.getContext('2d') : null;
                
                this.pieceMap = {
                    'K': '帅', 'A': '仕', 'B': '象', 'R': '車', 'N': '马', 'C': '炮', 'P': '兵',
                    'k': '将', 'a': '士', 'b': '相', 'r': '车', 'n': '马', 'c': '炮', 'p': '卒'
                };
            }
            
            connect(address) {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${address}`;
                
                console.log('连接服务器:', wsUrl);
                
                this.socket = new WebSocket(wsUrl);
                
                this.socket.onopen = () => {
                    console.log('WebSocket连接成功');
                    this.updateStatus('已连接到服务器', 'success');
                    this.showRoomControls();
                };
                
                this.socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleServerMessage(data);
                    } catch (error) {
                        console.error('消息解析错误:', error);
                    }
                };
                
                this.socket.onclose = () => {
                    console.log('WebSocket连接关闭');
                    this.updateStatus('连接已断开', 'error');
                    this.resetGame();
                };
                
                this.socket.onerror = (error) => {
                    console.error('WebSocket错误:', error);
                    this.updateStatus('连接错误，请检查服务器地址', 'error');
                };
            }
            
            handleServerMessage(data) {
                console.log('收到服务器消息:', data.type);
                
                switch (data.type) {
                    case 'welcome':
                        this.clientId = data.clientId;
                        this.updateStatus(`已连接，客户端ID: ${this.clientId}`, 'success');
                        break;
                    case 'room_created':
                        this.handleRoomCreated(data);
                        break;
                    case 'room_joined':
                        this.handleRoomJoined(data);
                        break;
                    case 'room_list':
                        this.displayRoomList(data.rooms);
                        break;
                    case 'player_joined':
                        this.handlePlayerJoined(data);
                        break;
                    case 'player_left':
                        this.handlePlayerLeft(data);
                        break;
                    case 'move':
                        this.handleServerMove(data);
                        break;
                    case 'chat':
                        this.handleChatMessage(data);
                        break;
                    case 'game_restarted':
                        this.handleGameRestarted(data);
                        break;
                    case 'tank_state':
                        this.handleTankState(data);
                        break;
                    case 'error':
                        alert(data.message);
                        break;
                }
            }
            
            handleRoomCreated(data) {
                this.roomId = data.roomId;
                this.playerColor = data.color;
                this.gameState = data.gameState;
                this.gameType = data.gameType || 'chess';
                
                this.updateStatus(`房间创建成功! 房间号: ${this.roomId}`, 'success');
                this.showGameInterface();
                if (this.gameType === 'chess') {
                    document.getElementById('chessboard').style.display = 'block';
                    document.getElementById('tankContainer').style.display = 'none';
                    this.stopTankInputLoop();
                    this.renderBoard();
                } else {
                    this.setupTankMode();
                }
                this.updatePlayerInfo();
                
                this.addChatMessage('系统', data.message || '等待其他玩家加入...', true);
            }
            
            handleRoomJoined(data) {
                this.roomId = data.roomId;
                this.playerColor = data.color;
                this.gameState = data.gameState;
                this.gameType = data.gameType || 'chess';
                
                this.updateStatus(`加入房间成功! 房间号: ${this.roomId}`, 'success');
                this.showGameInterface();
                if (this.gameType === 'chess') {
                    document.getElementById('chessboard').style.display = 'block';
                    document.getElementById('tankContainer').style.display = 'none';
                    this.stopTankInputLoop();
                    this.renderBoard();
                } else {
                    this.setupTankMode();
                }
                this.updatePlayerInfo();
                
                this.addChatMessage('系统', data.message || '游戏开始!', true);
            }
            
            handlePlayerJoined(data) {
                this.addChatMessage('系统', `玩家 ${data.clientId} 已加入房间`, true);
                this.addChatMessage('系统', data.message || '游戏开始!', true);
            }
            
            handlePlayerLeft(data) {
                this.addChatMessage('系统', `玩家 ${data.clientId} 已离开房间`, true);
                this.addChatMessage('系统', '等待其他玩家重新加入...', true);
            }
            
            handleServerMove(data) {
                const { from, to, piece, captures, turn, board, clientId, gameOver, winner } = data;

                if (this.gameType !== 'chess') return;

                // 1. 使用服务端下发的权威棋盘（如果有）
                if (board) {
                    this.gameState.board = board;
                } else if (this.gameState && this.gameState.board) {
                    // 向后兼容：如果没发棋盘，就按“移动-覆盖”更新
                    this.gameState.board[to.row][to.col] = piece;
                    this.gameState.board[from.row][from.col] = null;
                }

                // 2. 更新当前回合与结束状态
                if (typeof turn !== 'undefined') {
                    this.gameState.turn = turn;
                }
                if (typeof gameOver !== 'undefined') {
                    this.gameState.gameOver = gameOver;
                    this.gameState.winner = winner || null;
                }

                // 3. 添加移动记录
                this.addMoveToHistory(piece, from, to, !!captures);

                // 4. 重新渲染棋盘
                this.clearSelection();
                this.renderBoard();
                this.updatePlayerInfo();

                // 若游戏结束，提示胜负并禁止继续走子
                if (this.gameState.gameOver) {
                    const winText =
                        this.gameState.winner === 'red' ? '红方胜利！' :
                        this.gameState.winner === 'black' ? '黑方胜利！' :
                        '游戏结束';
                    this.addChatMessage('系统', winText, true);
                }

                // 5. 播放音效
                this.playSound(captures ? 'capture' : 'move');

                // 6. 在聊天框显示移动信息（区分自己/对手）
                const pieceName = this.pieceMap[piece];
                const moveInfo = `${pieceName}从(${9-from.row},${from.col})移动到(${9-to.row},${to.col})`;
                const captureInfo = captures ? '并吃子！' : '';
                const who = clientId === this.clientId ? '你' : '对手';
                this.addChatMessage('系统', `${who}${moveInfo}${captureInfo}`, true);
            }

            // Tank: 初始化模式
            setupTankMode() {
                document.getElementById('chessboard').style.display = 'none';
                document.getElementById('tankContainer').style.display = 'block';
                this.tankState = this.gameState; // 服务器会立即推送权威状态
                this.startTankInputLoop();
                this.renderTank();
            }

            handleTankState(data) {
                if (this.gameType !== 'tank') return;
                this.tankState = {
                    players: data.players || {},
                    bullets: data.bullets || [],
                    gameOver: !!data.gameOver,
                    winner: data.winner || null
                };
                this.renderTank();
                if (this.tankState.gameOver) {
                    const text = this.tankState.winner
                        ? (this.tankState.winner === 'red' ? '红方胜利！' : '蓝方胜利！')
                        : '平局';
                    this.addChatMessage('系统', text, true);
                }
            }

            handleTankKey(e, down) {
                if (this.gameType !== 'tank') return;
                const code = e.key.toLowerCase();
                if (code === 'a') this.tankKeys.left = down;
                if (code === 'd') this.tankKeys.right = down;
                if (code === 'w') this.tankKeys.up = down;
                if (code === 's') this.tankKeys.down = down;
                if (code === 'j') this.tankKeys.shoot = down;
            }

            startTankInputLoop() {
                if (this.tankSendTimer) clearInterval(this.tankSendTimer);
                this.tankSendTimer = setInterval(() => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN && this.gameType === 'tank') {
                        this.socket.send(JSON.stringify({
                            type: 'tank_input',
                            keys: this.tankKeys
                        }));
                    }
                }, 50);
            }

            stopTankInputLoop() {
                if (this.tankSendTimer) {
                    clearInterval(this.tankSendTimer);
                    this.tankSendTimer = null;
                }
            }

            renderTank() {
                if (this.gameType !== 'tank' || !this.tankCtx) return;
                const ctx = this.tankCtx;
                const canvas = this.tankCanvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 背景与边框
                ctx.fillStyle = '#0f3b0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#ccc';
                ctx.strokeRect(18, 18, canvas.width - 36, canvas.height - 36);

                const state = this.tankState || {};
                const players = state.players || {};
                const bullets = state.bullets || [];

                // 画子弹
                bullets.forEach(b => {
                    ctx.beginPath();
                    ctx.fillStyle = b.color === 'red' ? '#ff4d4f' : '#4d8bff';
                    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // 画坦克
                Object.values(players).forEach(p => {
                    if (!p.isAlive) return;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.direction * Math.PI / 180);
                    ctx.fillStyle = p.color === 'red' ? '#ff4d4f' : '#4d8bff';
                    ctx.fillRect(-12, -12, 24, 24);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(-12, -12, 24, 24);
                    ctx.restore();

                    // 炮管
                    const rad = p.turretDirection * Math.PI / 180;
                    const ex = p.x + Math.cos(rad) * 18;
                    const ey = p.y + Math.sin(rad) * 18;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();

                    // 血条
                    const bw = 40, bh = 6;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(p.x - bw / 2, p.y - 26, bw, bh);
                    const ratio = Math.max(0, p.health / 100);
                    ctx.fillStyle = ratio > 0.5 ? '#0f0' : ratio > 0.2 ? '#ff0' : '#f00';
                    ctx.fillRect(p.x - bw / 2 + 1, p.y - 25, (bw - 2) * ratio, bh - 2);
                });

                // 状态文字
                if (state.gameOver) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '28px Arial';
                    const text = state.winner
                        ? (state.winner === 'red' ? '红方胜利' : '蓝方胜利')
                        : '平局';
                    ctx.fillText(text, canvas.width / 2 - ctx.measureText(text).width / 2, canvas.height / 2);
                }
            }
            
            handleChatMessage(data) {
                if (data.clientId === this.clientId) return;
                
                const sender = data.clientId === this.clientId ? '我' : '对手';
                this.addChatMessage(sender, data.message, false);
            }
            
            handleGameRestarted(data) {
                this.gameState = data.gameState;
                this.gameState.turn = data.turn;
                
                this.clearSelection();
                this.renderBoard();
                this.updatePlayerInfo();
                this.clearMoveHistory();
                
                this.addChatMessage('系统', data.message || '游戏已重新开始', true);
                this.playSound('select');
            }
            
            createRoom() {
                if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                    alert('请先连接到服务器');
                    return;
                }
                const gameType = document.getElementById('gameSelect')?.value || 'chess';
                
                this.socket.send(JSON.stringify({
                    type: 'create_room',
                    gameType
                }));
                
                this.updateStatus('正在创建房间...', 'info');
            }
            
            joinRoom(roomId) {
                if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                    alert('请先连接到服务器');
                    return;
                }
                
                this.socket.send(JSON.stringify({
                    type: 'join_room',
                    roomId: roomId
                }));
                
                this.updateStatus('正在加入房间...', 'info');
            }
            
            sendMove(from, to, piece) {
                if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
                
                this.socket.send(JSON.stringify({
                    type: 'move',
                    from: from,
                    to: to,
                    piece: piece
                }));
            }
            
            sendChatMessage(message) {
                if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
                
                this.socket.send(JSON.stringify({
                    type: 'chat',
                    message: message
                }));
                
                this.addChatMessage('我', message, false);
            }
            
            restartGame() {
                if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
                
                if (confirm('确定要重新开始游戏吗？')) {
                    this.socket.send(JSON.stringify({
                        type: 'restart'
                    }));
                }
            }
            
            renderBoard() {
                if (this.gameType !== 'chess') return;
                if (!this.gameState || !this.gameState.board) return;
                
                const board = document.getElementById('chessboard');
                board.innerHTML = '<div class="river">楚河        汉界</div>';
                
                this.drawBoardGrid();
                
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece) {
                            this.createPieceElement(piece, row, col);
                        }
                    }
                }
                
                this.renderValidMoves();
            }
            
            drawBoardGrid() {
                const board = document.getElementById('chessboard');
                
                // 绘制垂直线
                for (let i = 0; i <= 8; i++) {
                    const line = document.createElement('div');
                    line.className = 'grid-line';
                    line.style.left = `${i * 60}px`;
                    line.style.top = '0';
                    line.style.width = '1px';
                    line.style.height = '100%';
                    board.appendChild(line);
                }
                
                // 绘制水平线
                for (let i = 0; i <= 9; i++) {
                    const line = document.createElement('div');
                    line.className = 'grid-line';
                    line.style.left = '0';
                    line.style.top = `${i * 60}px`;
                    line.style.width = '100%';
                    line.style.height = '1px';
                    board.appendChild(line);
                }
                
                // // 绘制九宫格斜线
                // const palaceLines = [
                //     { x1: 180, y1: 420, x2: 360, y2: 660 },
                //     { x1: 360, y1: 420, x2: 180, y2: 660 },
                //     { x1: 180, y1: 0, x2: 360, y2: 180 },
                //     { x1: 360, y1: 0, x2: 180, y2: 180 }
                // ];
                
                // palaceLines.forEach(line => {
                //     const div = document.createElement('div');
                //     div.className = 'grid-line';
                //     div.style.position = 'absolute';
                //     div.style.left = `${Math.min(line.x1, line.x2)}px`;
                //     div.style.top = `${Math.min(line.y1, line.y2)}px`;
                //     div.style.width = `${Math.abs(line.x2 - line.x1)}px`;
                //     div.style.height = '1px';
                //     div.style.transform = `rotate(${Math.atan2(line.y2 - line.y1, line.x2 - line.x1)}rad)`;
                //     div.style.transformOrigin = '0 0';
                //     board.appendChild(div);
                // });
            }
            
            createPieceElement(pieceCode, row, col) {
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${pieceCode === pieceCode.toUpperCase() ? 'red' : 'black'}`;
                pieceElement.textContent = this.pieceMap[pieceCode];
                pieceElement.dataset.row = row;
                pieceElement.dataset.col = col;
                pieceElement.dataset.piece = pieceCode;

                pieceElement.style.left = `${col * 60 + 2}px`;
                pieceElement.style.top = `${row * 60 + 2}px`;

                // 统一由 handlePieceClick 处理（选子 / 吃子）
                pieceElement.onclick = () => this.handlePieceClick(pieceCode, row, col);

                document.getElementById('chessboard').appendChild(pieceElement);
            }

            handlePieceClick(piece, row, col) {
                // 还未选中棋子，或者点击的是自己棋子：执行“选子”逻辑
                if (!this.selectedPiece || this.isSameColor(this.selectedPiece.piece, piece)) {
                    this.selectPiece(piece, row, col);
                    return;
                }

                // 已选中自己的棋子，再点到的是对方棋子：如果在合法走子范围内，则执行吃子
                const canCapture = this.validMoves.some(([r, c]) => r === row && c === col);
                if (canCapture) {
                    this.movePiece(row, col);
                } else {
                    // 非合法目标，给个声音提示
                    this.playSound('invalid');
                }
            }

            isSameColor(pieceA, pieceB) {
                const isRedA = pieceA === pieceA.toUpperCase();
                const isRedB = pieceB === pieceB.toUpperCase();
                return isRedA === isRedB;
            }

            selectPiece(piece, row, col) {
                if (this.gameType !== 'chess') return;
                if (!this.gameState || !this.gameActive()) return;
                
                const isRed = piece === piece.toUpperCase();
                const pieceColor = isRed ? 'red' : 'black';
                
                if (pieceColor !== this.playerColor || this.gameState.turn !== this.playerColor) {
                    this.playSound('invalid');
                    return;
                }
                
                document.querySelectorAll('.piece.selected').forEach(el => el.classList.remove('selected'));
                
                const pieceElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (pieceElement) {
                    pieceElement.classList.add('selected');
                    this.playSound('select');
                }
                
                this.selectedPiece = { piece, row, col };
                this.validMoves = this.calculateValidMoves(piece, row, col);
                this.renderValidMoves();
            }
            
            calculateValidMoves(piece, row, col) {
                const moves = [];
                const validMoves = ChessRules.getAllValidMoves(this.gameState.board, row, col);
                
                validMoves.forEach(move => {
                    moves.push([move.row, move.col]);
                });
                
                return moves;
            }
            
            renderValidMoves() {
                document.querySelectorAll('.valid-move').forEach(el => el.remove());
                
                this.validMoves.forEach(([row, col]) => {
                    const indicator = document.createElement('div');
                    indicator.className = 'valid-move';
                    indicator.style.left = `${col * 60 + 22}px`;
                    indicator.style.top = `${row * 60 + 22}px`;
                    indicator.onclick = () => this.movePiece(row, col);
                    document.getElementById('chessboard').appendChild(indicator);
                });
            }
            
            movePiece(toRow, toCol) {
                if (!this.selectedPiece) return;
                
                const { piece, row: fromRow, col: fromCol } = this.selectedPiece;
                
                this.sendMove(
                    { row: fromRow, col: fromCol },
                    { row: toRow, col: toCol },
                    piece
                );
            }
            
            addMoveToHistory(piece, from, to, captures) {
                const pieceName = this.pieceMap[piece];
                const fromPos = `(${9-from.row}, ${from.col})`;
                const toPos = `(${9-to.row}, ${to.col})`;
                const captureText = captures ? '吃子' : '';
                const moveText = `${pieceName} ${fromPos} → ${toPos} ${captureText}`;
                
                const historyElement = document.getElementById('moveHistory');
                const moveElement = document.createElement('div');
                moveElement.className = 'move-record';
                moveElement.textContent = moveText;
                historyElement.appendChild(moveElement);
                historyElement.scrollTop = historyElement.scrollHeight;
            }
            
            clearMoveHistory() {
                document.getElementById('moveHistory').innerHTML = '';
            }
            
            addChatMessage(sender, message, isSystem = false) {
                const chatElement = document.getElementById('chatMessages');
                const messageElement = document.createElement('div');
                
                messageElement.className = `chat-message ${isSystem ? 'system' : (sender === '我' ? '' : 'opponent')}`;
                messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
                
                chatElement.appendChild(messageElement);
                chatElement.scrollTop = chatElement.scrollHeight;
            }
            
            clearSelection() {
                this.selectedPiece = null;
                this.validMoves = [];
                document.querySelectorAll('.piece.selected').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.valid-move').forEach(el => el.remove());
            }
            
            updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = message;
                statusElement.style.color = type === 'success' ? '#4CAF50' : 
                                          type === 'error' ? '#f44336' : '#2196F3';
            }
            
            updatePlayerInfo() {
                if (this.playerColor) {
                    document.getElementById('playerColor').textContent = 
                        this.playerColor === 'red' ? '红方' : '黑方';
                    document.getElementById('playerColor').style.color = 
                        this.playerColor === 'red' ? '#B22222' : '#000000';
                }
                
                if (this.gameState && this.gameState.turn) {
                    document.getElementById('currentTurn').textContent = 
                        this.gameState.turn === 'red' ? '红方' : '黑方';
                    document.getElementById('currentTurn').style.color = 
                        this.gameState.turn === 'red' ? '#B22222' : '#000000';
                }
                
                if (this.roomId) {
                    document.getElementById('roomId').textContent = this.roomId;
                }
            }
            
            displayRoomList(rooms) {
                const roomListElement = document.getElementById('roomList');
                roomListElement.innerHTML = '';
                
                if (rooms.length === 0) {
                    roomListElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">暂无可用房间</div>';
                    return;
                }
                
                rooms.forEach(room => {
                    const roomElement = document.createElement('div');
                    roomElement.className = 'room-item';
                    roomElement.innerHTML = `
                        <div><strong>房间号:</strong> ${room.id}</div>
                        <div><strong>游戏:</strong> ${room.gameType === 'tank' ? '坦克大战' : '中国象棋'}</div>
                        <div><strong>玩家:</strong> ${room.playerCount}/2</div>
                        <div><small>创建时间: ${new Date(room.created).toLocaleTimeString()}</small></div>
                    `;
                    
                    if (room.playerCount < 2) {
                        roomElement.onclick = () => this.joinRoom(room.id);
                    } else {
                        roomElement.style.opacity = '0.6';
                        roomElement.style.cursor = 'not-allowed';
                        roomElement.innerHTML += '<div style="color: #f44336;">房间已满</div>';
                    }
                    
                    roomListElement.appendChild(roomElement);
                });
                
                document.getElementById('roomListContainer').style.display = 'block';
            }
            
            showRoomControls() {
                document.getElementById('roomListContainer').style.display = 'block';
            }
            
            showGameInterface() {
                document.getElementById('connectionPanel').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
            }
            
            gameActive() {
                return this.gameState && this.roomId && this.playerColor && !this.gameState.gameOver;
            }
            
            playSound(type) {
                if (!this.soundEnabled) return;
                
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    switch (type) {
                        case 'select':
                            oscillator.frequency.value = 523.25;
                            break;
                        case 'move':
                            oscillator.frequency.value = 659.25;
                            break;
                        case 'capture':
                            oscillator.frequency.value = 783.99;
                            break;
                        case 'invalid':
                            oscillator.frequency.value = 349.23;
                            break;
                    }
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    console.log('音效播放失败:', e);
                }
            }
            
            resetGame() {
                this.roomId = null;
                this.playerColor = null;
                this.gameState = null;
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameType = 'chess';
                this.stopTankInputLoop();
                document.getElementById('tankContainer').style.display = 'none';
                document.getElementById('chessboard').style.display = 'block';
                
                document.getElementById('connectionPanel').style.display = 'block';
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('roomListContainer').style.display = 'none';
            }
        }

        // 全局游戏实例
        const game = new OnlineChessGame();

        // Tank 键盘监听
        window.addEventListener('keydown', (e) => game.handleTankKey(e, true));
        window.addEventListener('keyup', (e) => game.handleTankKey(e, false));

        // 全局函数
        function connectToServer() {
            let address = document.getElementById('serverAddress').value.trim();
            
            if (!address) {
                address = window.location.hostname + ':3000';
            }
            
            address = address.replace(/^https?:\/\//, '');
            
            game.connect(address);
        }

        function createRoom() {
            game.createRoom();
        }

        function refreshRoomList() {
            if (game.socket && game.socket.readyState === WebSocket.OPEN) {
                game.socket.send(JSON.stringify({
                    type: 'get_rooms'
                }));
                game.updateStatus('刷新房间列表中...', 'info');
            } else {
                alert('请先连接到服务器');
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message) {
                game.sendChatMessage(message);
                input.value = '';
                input.focus();
            }
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        function restartGame() {
            game.restartGame();
        }

        function surrenderGame() {
            if (confirm('确定要认输吗？')) {
                game.addChatMessage('系统', '你已认输，游戏结束！', true);
                game.playSound('invalid');
            }
        }

        function toggleSound() {
            game.soundEnabled = !game.soundEnabled;
            const btn = document.querySelector('button[onclick="toggleSound()"]');
            btn.textContent = `音效: ${game.soundEnabled ? '开' : '关'}`;
            game.playSound('select');
        }

        // 页面加载时自动获取当前IP
        window.onload = function() {
            try {
                const currentHost = window.location.hostname;
                if (currentHost && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {
                    document.getElementById('serverAddress').value = currentHost + ':3000';
                }
            } catch (e) {
                console.log('无法获取当前主机名');
            }
        };
    </script>
</body>
</html>